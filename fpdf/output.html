<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>fpdf.output API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fpdf.output</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># pylint: disable=protected-access
import hashlib, logging, zlib
from collections import OrderedDict
from contextlib import contextmanager
from io import BytesIO

from .enums import SignatureFlag
from .errors import FPDFException
from .drawing import render_pdf_primitive
from .outline import serialize_outline
from .sign import Signature, sign_content
from .syntax import create_dictionary_string as pdf_dict
from .syntax import create_list_string as pdf_list
from .syntax import create_stream as pdf_stream
from .syntax import iobj_ref as pdf_ref
from .util import enclose_in_parens, escape_parens, format_date, object_id_for_page

from fontTools import ttLib
from fontTools import subset as ftsubset

try:
    from endesive import signer
except ImportError:
    signer = None


LOGGER = logging.getLogger(__name__)

ZOOM_CONFIGS = {  # cf. section 8.2.1 &#34;Destinations&#34; of the 2006 PDF spec 1.7:
    &#34;fullpage&#34;: (&#34;/Fit&#34;,),
    &#34;fullwidth&#34;: (&#34;/FitH&#34;, &#34;null&#34;),
    &#34;real&#34;: (&#34;/XYZ&#34;, &#34;null&#34;, &#34;null&#34;, &#34;1&#34;),
}


class OutputProducer:
    &#34;Generates the final bytearray representing the PDF document, based on a FPDF instance.&#34;

    def __init__(self, fpdf):
        self.fpdf = fpdf
        self.buffer = bytearray()  # resulting output buffer
        # array of PDF object offsets in self.buffer, used to build the xref table:
        self.offsets = {}
        self.n = 2  # current PDF object number
        self._graphics_state_obj_refs = None
        self._embedded_files_per_pdf_ref = None
        # Truthy only if a Structure Tree is added to the document:
        self._struct_tree_root_obj_id = None
        # Truthy only if an Outline is added to the document:
        self._outlines_obj_id = None
        # Truthy only if XMP metadata is added to the document:
        self._xmp_metadata_obj_id = None

    def bufferize(self):
        &#34;&#34;&#34;
        This operation alters the target FPDF instance
        through calls to ._insert_table_of_contents(), ._substitute_page_number(),
        _set_min_pdf_version() &amp; _final_pdf_version()
        &#34;&#34;&#34;
        # * PDF object 1 is always the pages root
        # * PDF object 2 is always the resources dictionary
        # Those objects are not inserted first in the document though
        LOGGER.debug(&#34;Final doc sections size summary:&#34;)
        fpdf = self.fpdf
        with self._trace_size(&#34;header&#34;):
            self._out(f&#34;%PDF-{fpdf._final_pdf_version()}&#34;)
        self._build_embedded_files_per_pdf_ref()
        # It is important that pages are the first PDF objects inserted in the document,
        # followed immediately by annotations: some parts of fpdf2 currently rely on that
        # order of insertion (e.g. util.object_id_for_page):
        with self._trace_size(&#34;pages&#34;):
            self._put_pages()
        with self._trace_size(&#34;annotations_objects&#34;):
            sig_annotation_obj_id = self._put_annotations_as_objects()
        with self._trace_size(&#34;embedded_files&#34;):
            self._put_embedded_files()
        self._put_resources()  # trace_size is performed inside
        if not fpdf.struct_builder.empty():
            with self._trace_size(&#34;structure_tree&#34;):
                self._put_structure_tree()
        else:
            self._struct_tree_root_obj_id = False
        if fpdf._outline:
            with self._trace_size(&#34;document_outline&#34;):
                self._put_document_outline()
        else:
            self._outlines_obj_id = False
        if fpdf.xmp_metadata:
            self._put_xmp_metadata()
        else:
            self._xmp_metadata_obj_id = False
        with self._trace_size(&#34;info&#34;):
            info_obj_id = self._put_info()
        with self._trace_size(&#34;catalog&#34;):
            catalog_obj_id = self._put_catalog(sig_annotation_obj_id)
        with self._trace_size(&#34;xref&#34;):  #  cross-reference table
            startxref = len(self.buffer)
            self._out(&#34;xref&#34;)
            self._out(f&#34;0 {self.n + 1}&#34;)
            self._out(&#34;0000000000 65535 f &#34;)
            for i in range(1, self.n + 1):
                self._out(f&#34;{self.offsets[i]:010} 00000 n &#34;)
        with self._trace_size(&#34;trailer&#34;):
            self._put_trailer(info_obj_id, catalog_obj_id, startxref)
        self._out(&#34;%%EOF&#34;)
        if fpdf._sign_key:
            self.buffer = sign_content(
                signer,
                self.buffer,
                fpdf._sign_key,
                fpdf._sign_cert,
                fpdf._sign_extra_certs,
                fpdf._sign_hashalgo,
                fpdf._sign_time,
            )
        return self.buffer

    def _out(self, s):
        if not isinstance(s, bytes):
            if not isinstance(s, str):
                s = str(s)
            s = s.encode(&#34;latin1&#34;)
        self.buffer += s + b&#34;\n&#34;

    def _newobj(self):
        &#34;Begin a new PDF object&#34;
        self.n += 1
        self.offsets[self.n] = len(self.buffer)
        self._out(f&#34;{self.n} 0 obj&#34;)
        return self.n

    def _build_embedded_files_per_pdf_ref(self):
        assert self._embedded_files_per_pdf_ref is None
        fpdf = self.fpdf
        self._embedded_files_per_pdf_ref = {}
        first_annot_obj_id = object_id_for_page(fpdf.pages_count) + 2
        annotations_count = sum(
            len(page_annots_as_obj)
            for page_annots_as_obj in fpdf.annots_as_obj.values()
        )
        for n, embedd_file in enumerate(
            fpdf.embedded_files, start=first_annot_obj_id + annotations_count
        ):
            self._embedded_files_per_pdf_ref[pdf_ref(n)] = embedd_file

    def _put_pages(self):
        fpdf = self.fpdf
        if fpdf._toc_placeholder:
            fpdf._insert_table_of_contents()
        if fpdf.str_alias_nb_pages:
            fpdf._substitute_page_number()
        if fpdf.def_orientation == &#34;P&#34;:
            dw_pt = fpdf.dw_pt
            dh_pt = fpdf.dh_pt
        else:
            dw_pt = fpdf.dh_pt
            dh_pt = fpdf.dw_pt
        compression_filter = &#34;/Filter /FlateDecode &#34; if fpdf.compress else &#34;&#34;

        # The Annotations embedded as PDF objects
        # are added to the document just after all the pages,
        # hence we can deduce their object IDs:
        annot_obj_id = object_id_for_page(fpdf.pages_count) + 2

        for n in range(1, fpdf.pages_count + 1):
            # Page
            self._newobj()
            self._out(&#34;&lt;&lt;/Type /Page&#34;)
            self._out(f&#34;/Parent {pdf_ref(1)}&#34;)
            page = fpdf.pages[n]
            if page[&#34;duration&#34;]:
                self._out(f&#34;/Dur {page[&#39;duration&#39;]}&#34;)
            if page[&#34;transition&#34;]:
                self._out(f&#34;/Trans {page[&#39;transition&#39;].dict_as_string()}&#34;)
            w_pt, h_pt = page[&#34;w_pt&#34;], page[&#34;h_pt&#34;]
            if w_pt != dw_pt or h_pt != dh_pt:
                self._out(f&#34;/MediaBox [0 0 {w_pt:.2f} {h_pt:.2f}]&#34;)
            self._out(f&#34;/Resources {pdf_ref(2)}&#34;)
            annot_obj_id = self._put_page_annotations(n, annot_obj_id)
            if fpdf.pdf_version &gt; &#34;1.3&#34;:
                self._out(&#34;/Group &lt;&lt;/Type /Group /S /Transparency /CS /DeviceRGB&gt;&gt;&#34;)
            spid = fpdf._struct_parents_id_per_page.get(self.n)
            if spid is not None:
                self._out(f&#34;/StructParents {spid}&#34;)
            self._out(f&#34;/Contents {pdf_ref(self.n + 1)}&gt;&gt;&#34;)
            self._out(&#34;endobj&#34;)

            # Page content
            content = page[&#34;content&#34;]
            p = zlib.compress(content) if fpdf.compress else content
            self._newobj()
            self._out(f&#34;&lt;&lt;{compression_filter}/Length {len(p)}&gt;&gt;&#34;)
            self._out(pdf_stream(p))
            self._out(&#34;endobj&#34;)
        # Pages root
        self.offsets[1] = len(self.buffer)
        self._out(&#34;1 0 obj&#34;)
        self._out(&#34;&lt;&lt;/Type /Pages&#34;)
        self._out(
            &#34;/Kids [&#34;
            + &#34; &#34;.join(
                pdf_ref(object_id_for_page(page))
                for page in range(1, fpdf.pages_count + 1)
            )
            + &#34;]&#34;
        )
        self._out(f&#34;/Count {fpdf.pages_count}&#34;)
        self._out(f&#34;/MediaBox [0 0 {dw_pt:.2f} {dh_pt:.2f}]&#34;)
        self._out(&#34;&gt;&gt;&#34;)
        self._out(&#34;endobj&#34;)

    def _put_page_annotations(self, page_number, annot_obj_id):
        fpdf = self.fpdf
        page_annots = fpdf.annots[page_number]
        page_annots_as_obj = fpdf.annots_as_obj[page_number]
        if page_annots or page_annots_as_obj:
            # Annotations, e.g. links:
            annots = &#34;&#34;
            for annot in page_annots:
                annots += serialize_annot(annot, fpdf, self._embedded_files_per_pdf_ref)
                if annot.quad_points:
                    # This won&#39;t alter the PDF header, that has already been rendered,
                    # but can trigger the insertion of a /Page /Group by _put_pages:
                    fpdf._set_min_pdf_version(&#34;1.6&#34;)
            if page_annots and page_annots_as_obj:
                annots += &#34; &#34;
            annots += &#34; &#34;.join(
                f&#34;{annot_obj_id + i} 0 R&#34; for i in range(len(page_annots_as_obj))
            )
            annot_obj_id += len(page_annots_as_obj)
            self._out(f&#34;/Annots [{annots}]&#34;)
        return annot_obj_id

    def _put_annotations_as_objects(self):
        fpdf = self.fpdf
        sig_annotation_obj_id = None
        # The following code inserts annotations in the order
        # they have been inserted in the pages / .annots_as_obj dict;
        # this relies on a property of Python dicts since v3.7:
        for page_annots_as_obj in fpdf.annots_as_obj.values():
            for annot in page_annots_as_obj:
                self._newobj()
                self._out(
                    serialize_annot(annot, fpdf, self._embedded_files_per_pdf_ref)
                )
                self._out(&#34;endobj&#34;)
                if isinstance(annot.value, Signature):
                    sig_annotation_obj_id = self.n
        return sig_annotation_obj_id

    def _put_embedded_files(self):
        for embedd_file in self.fpdf.embedded_files:
            stream_dict = {
                &#34;/Type&#34;: &#34;/EmbeddedFile&#34;,
            }
            stream_content = embedd_file.bytes
            if embedd_file.compress:
                stream_dict[&#34;/Filter&#34;] = &#34;/FlateDecode&#34;
                stream_content = zlib.compress(stream_content)
            stream_dict[&#34;/Length&#34;] = len(stream_content)
            params = {
                &#34;/Size&#34;: len(embedd_file.bytes),
            }
            if embedd_file.creation_date:
                params[&#34;/CreationDate&#34;] = format_date(
                    embedd_file.creation_date, with_tz=True
                )
            if embedd_file.modification_date:
                params[&#34;/ModDate&#34;] = format_date(
                    embedd_file.modification_date, with_tz=True
                )
            if embedd_file.checksum:
                file_hash = hashlib.new(&#34;md5&#34;, usedforsecurity=False)
                file_hash.update(stream_content)
                hash_hex = file_hash.hexdigest()
                params[&#34;/CheckSum&#34;] = f&#34;&lt;{hash_hex}&gt;&#34;
            stream_dict[&#34;/Params&#34;] = pdf_dict(params)
            self._newobj()
            self._out(pdf_dict(stream_dict))
            self._out(pdf_stream(stream_content))
            self._out(&#34;endobj&#34;)
            assert self._embedded_files_per_pdf_ref[pdf_ref(self.n)] == embedd_file

    def _put_resources(self):
        with self._trace_size(&#34;resources.fonts&#34;):
            self._put_fonts()
        with self._trace_size(&#34;resources.images&#34;):
            self._put_images()
        with self._trace_size(&#34;resources.gfxstate&#34;):
            self._put_graphics_state_dicts()

        # Resource dictionary
        with self._trace_size(&#34;resources.dict&#34;):
            self._put_resource_dict()

    def _put_fonts(self):
        fpdf = self.fpdf
        flist = [(x[1][&#34;i&#34;], x[0], x[1]) for x in fpdf.fonts.items()]
        flist.sort()
        for _, font_name, font in flist:
            fpdf.fonts[font_name][&#34;n&#34;] = self.n + 1
            # Standard font
            if font[&#34;type&#34;] == &#34;core&#34;:
                self._newobj()
                self._out(&#34;&lt;&lt;/Type /Font&#34;)
                self._out(f&#34;/BaseFont /{font[&#39;name&#39;]}&#34;)
                self._out(&#34;/Subtype /Type1&#34;)
                if font[&#34;name&#34;] not in (&#34;Symbol&#34;, &#34;ZapfDingbats&#34;):
                    self._out(&#34;/Encoding /WinAnsiEncoding&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(&#34;endobj&#34;)
            elif font[&#34;type&#34;] == &#34;TTF&#34;:
                fontname = f&#34;MPDFAA+{font[&#39;name&#39;]}&#34;

                # unicode_char -&gt; new_code_char map for chars embedded in the PDF
                uni_to_new_code_char = font[&#34;subset&#34;].dict()

                # why we delete 0-element?
                del uni_to_new_code_char[0]

                # ---- FONTTOOLS SUBSETTER ----
                # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
                # if we leave recalcTimestamp=True the tests will break every time
                fonttools_font = ttLib.TTFont(
                    file=font[&#34;ttffile&#34;], recalcTimestamp=False
                )

                # 1. get all glyphs in PDF
                cmap = fonttools_font[&#34;cmap&#34;].getBestCmap()
                glyph_names = [
                    cmap[unicode] for unicode in uni_to_new_code_char if unicode in cmap
                ]

                # 2. make a subset
                # notdef_outline=True means that keeps the white box for the .notdef glyph
                # recommended_glyphs=True means that adds the .notdef, .null, CR, and space glyphs
                options = ftsubset.Options(notdef_outline=True, recommended_glyphs=True)
                # dropping the tables previous dropped in the old ttfonts.py file #issue 418
                options.drop_tables += [&#34;GDEF&#34;, &#34;GSUB&#34;, &#34;GPOS&#34;, &#34;MATH&#34;, &#34;hdmx&#34;]
                subsetter = ftsubset.Subsetter(options)
                subsetter.populate(glyphs=glyph_names)
                subsetter.subset(fonttools_font)

                # 3. make codeToGlyph
                # is a map Character_ID -&gt; Glyph_ID
                # it&#39;s used for associating glyphs to new codes
                # this basically takes the old code of the character
                # take the glyph associated with it
                # and then associate to the new code the glyph associated with the old code
                code_to_glyph = {}
                for code, new_code_mapped in uni_to_new_code_char.items():
                    if code in cmap:
                        glyph_name = cmap[code]
                        code_to_glyph[new_code_mapped] = fonttools_font.getGlyphID(
                            glyph_name
                        )
                    else:
                        # notdef is associated if no glyph was associated to the old code
                        # it&#39;s not necessary to do this, it seems to be done by default
                        code_to_glyph[new_code_mapped] = fonttools_font.getGlyphID(
                            &#34;.notdef&#34;
                        )

                # 4. return the ttfile
                output = BytesIO()
                fonttools_font.save(output)

                output.seek(0)
                ttfontstream = output.read()
                ttfontsize = len(ttfontstream)
                fontstream = zlib.compress(ttfontstream)

                # Type0 Font
                # A composite font - a font composed of other fonts,
                # organized hierarchically
                self._newobj()
                self._out(&#34;&lt;&lt;/Type /Font&#34;)
                self._out(&#34;/Subtype /Type0&#34;)
                self._out(f&#34;/BaseFont /{fontname}&#34;)
                self._out(&#34;/Encoding /Identity-H&#34;)
                self._out(f&#34;/DescendantFonts [{pdf_ref(self.n + 1)}]&#34;)
                self._out(f&#34;/ToUnicode {pdf_ref(self.n + 2)}&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(&#34;endobj&#34;)

                # CIDFontType2
                # A CIDFont whose glyph descriptions are based on
                # TrueType font technology
                self._newobj()
                self._out(&#34;&lt;&lt;/Type /Font&#34;)
                self._out(&#34;/Subtype /CIDFontType2&#34;)
                self._out(f&#34;/BaseFont /{fontname}&#34;)
                self._out(f&#34;/CIDSystemInfo {pdf_ref(self.n + 2)}&#34;)
                self._out(f&#34;/FontDescriptor {pdf_ref(self.n + 3)}&#34;)
                if font[&#34;desc&#34;].get(&#34;MissingWidth&#34;):
                    self._out(f&#34;/DW {font[&#39;desc&#39;][&#39;MissingWidth&#39;]}&#34;)
                self._out(_put_TT_font_widths(font, max(uni_to_new_code_char)))
                self._out(f&#34;/CIDToGIDMap {pdf_ref(self.n + 4)}&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(&#34;endobj&#34;)

                # bfChar
                # This table informs the PDF reader about the unicode
                # character that each used 16-bit code belongs to. It
                # allows searching the file and copying text from it.
                bfChar = []
                uni_to_new_code_char = font[&#34;subset&#34;].dict()
                for code in uni_to_new_code_char:
                    code_mapped = uni_to_new_code_char.get(code)
                    if code &gt; 0xFFFF:
                        # Calculate surrogate pair
                        code_high = 0xD800 | (code - 0x10000) &gt;&gt; 10
                        code_low = 0xDC00 | (code &amp; 0x3FF)
                        bfChar.append(
                            f&#34;&lt;{code_mapped:04X}&gt; &lt;{code_high:04X}{code_low:04X}&gt;\n&#34;
                        )
                    else:
                        bfChar.append(f&#34;&lt;{code_mapped:04X}&gt; &lt;{code:04X}&gt;\n&#34;)

                # ToUnicode
                self._newobj()
                toUni = (
                    &#34;/CIDInit /ProcSet findresource begin\n&#34;
                    &#34;12 dict begin\n&#34;
                    &#34;begincmap\n&#34;
                    &#34;/CIDSystemInfo\n&#34;
                    &#34;&lt;&lt;/Registry (Adobe)\n&#34;
                    &#34;/Ordering (UCS)\n&#34;
                    &#34;/Supplement 0\n&#34;
                    &#34;&gt;&gt; def\n&#34;
                    &#34;/CMapName /Adobe-Identity-UCS def\n&#34;
                    &#34;/CMapType 2 def\n&#34;
                    &#34;1 begincodespacerange\n&#34;
                    &#34;&lt;0000&gt; &lt;FFFF&gt;\n&#34;
                    &#34;endcodespacerange\n&#34;
                    f&#34;{len(bfChar)} beginbfchar\n&#34;
                    f&#34;{&#39;&#39;.join(bfChar)}&#34;
                    &#34;endbfchar\n&#34;
                    &#34;endcmap\n&#34;
                    &#34;CMapName currentdict /CMap defineresource pop\n&#34;
                    &#34;end\n&#34;
                    &#34;end&#34;
                )
                self._out(f&#34;&lt;&lt;/Length {len(toUni)}&gt;&gt;&#34;)
                self._out(pdf_stream(toUni))
                self._out(&#34;endobj&#34;)

                # CIDSystemInfo dictionary
                self._newobj()
                self._out(&#34;&lt;&lt;/Registry (Adobe)&#34;)
                self._out(&#34;/Ordering (UCS)&#34;)
                self._out(&#34;/Supplement 0&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(&#34;endobj&#34;)

                # Font descriptor
                self._newobj()
                self._out(&#34;&lt;&lt;/Type /FontDescriptor&#34;)
                self._out(&#34;/FontName /&#34; + fontname)
                for key, value in font[&#34;desc&#34;].items():
                    self._out(f&#34; /{key} {value}&#34;)
                self._out(f&#34;/FontFile2 {pdf_ref(self.n + 2)}&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(&#34;endobj&#34;)

                # Embed CIDToGIDMap
                # A specification of the mapping from CIDs to glyph indices
                cid_to_gid_map = [&#34;\x00&#34;] * 256 * 256 * 2
                for cc, glyph in code_to_glyph.items():
                    cid_to_gid_map[cc * 2] = chr(glyph &gt;&gt; 8)
                    cid_to_gid_map[cc * 2 + 1] = chr(glyph &amp; 0xFF)
                cid_to_gid_map = &#34;&#34;.join(cid_to_gid_map)

                # manage binary data as latin1 until PEP461-like function is implemented
                cid_to_gid_map = zlib.compress(cid_to_gid_map.encode(&#34;latin1&#34;))

                self._newobj()
                self._out(f&#34;&lt;&lt;/Length {len(cid_to_gid_map)}&#34;)
                self._out(&#34;/Filter /FlateDecode&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(pdf_stream(cid_to_gid_map))
                self._out(&#34;endobj&#34;)

                # Font file
                self._newobj()
                self._out(f&#34;&lt;&lt;/Length {len(fontstream)}&#34;)
                self._out(&#34;/Filter /FlateDecode&#34;)
                self._out(f&#34;/Length1 {ttfontsize}&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(pdf_stream(fontstream))
                self._out(&#34;endobj&#34;)

    def _put_images(self):
        for img_info in sorted(
            self.fpdf.images.values(), key=lambda img_info: img_info[&#34;i&#34;]
        ):
            if img_info[&#34;usages&#34;] &gt; 0:
                self._put_image(img_info)

    def _put_image(self, info):
        if &#34;data&#34; not in info:
            return
        self._newobj()
        info[&#34;n&#34;] = self.n
        self._out(&#34;&lt;&lt;/Type /XObject&#34;)
        self._out(&#34;/Subtype /Image&#34;)
        self._out(f&#34;/Width {info[&#39;w&#39;]}&#34;)
        self._out(f&#34;/Height {info[&#39;h&#39;]}&#34;)

        if info[&#34;cs&#34;] == &#34;Indexed&#34;:
            palette_ref = (
                pdf_ref(self.n + 2)
                if self.fpdf.allow_images_transparency and &#34;smask&#34; in info
                else pdf_ref(self.n + 1)
            )
            self._out(
                f&#34;/ColorSpace [/Indexed /DeviceRGB &#34;
                f&#34;{len(info[&#39;pal&#39;]) // 3 - 1} {palette_ref}]&#34;
            )
        else:
            self._out(f&#34;/ColorSpace /{info[&#39;cs&#39;]}&#34;)
            if info[&#34;cs&#34;] == &#34;DeviceCMYK&#34;:
                self._out(&#34;/Decode [1 0 1 0 1 0 1 0]&#34;)

        self._out(f&#34;/BitsPerComponent {info[&#39;bpc&#39;]}&#34;)

        if &#34;f&#34; in info:
            self._out(f&#34;/Filter /{info[&#39;f&#39;]}&#34;)
        if &#34;dp&#34; in info:
            self._out(f&#34;/DecodeParms &lt;&lt;{info[&#39;dp&#39;]}&gt;&gt;&#34;)

        if &#34;trns&#34; in info and isinstance(info[&#34;trns&#34;], list):
            trns = &#34; &#34;.join(f&#34;{x} {x}&#34; for x in info[&#34;trns&#34;])
            self._out(f&#34;/Mask [{trns}]&#34;)

        if self.fpdf.allow_images_transparency and &#34;smask&#34; in info:
            self._out(f&#34;/SMask {pdf_ref(self.n + 1)}&#34;)

        self._out(f&#34;/Length {len(info[&#39;data&#39;])}&gt;&gt;&#34;)
        self._out(pdf_stream(info[&#34;data&#34;]))
        self._out(&#34;endobj&#34;)

        # Soft mask
        if self.fpdf.allow_images_transparency and &#34;smask&#34; in info:
            dp = f&#34;/Predictor 15 /Colors 1 /BitsPerComponent 8 /Columns {info[&#39;w&#39;]}&#34;
            smask = {
                &#34;w&#34;: info[&#34;w&#34;],
                &#34;h&#34;: info[&#34;h&#34;],
                &#34;cs&#34;: &#34;DeviceGray&#34;,
                &#34;bpc&#34;: 8,
                &#34;f&#34;: info[&#34;f&#34;],
                &#34;dp&#34;: dp,
                &#34;data&#34;: info[&#34;smask&#34;],
            }
            self._put_image(smask)

        # Palette
        if info[&#34;cs&#34;] == &#34;Indexed&#34;:
            self._newobj()
            if self.fpdf.compress:
                pal_filter, pal_data = (
                    &#34;/Filter /FlateDecode &#34;,
                    zlib.compress(info[&#34;pal&#34;]),
                )
            else:
                pal_filter, pal_data = (&#34;&#34;, info[&#34;pal&#34;])
            self._out(f&#34;&lt;&lt;{pal_filter}/Length {len(pal_data)}&gt;&gt;&#34;)
            self._out(pdf_stream(pal_data))
            self._out(&#34;endobj&#34;)

    def _put_graphics_state_dicts(self):
        self._graphics_state_obj_refs = OrderedDict()
        for state_dict, name in self.fpdf._drawing_graphics_state_registry.items():
            self._newobj()
            self._graphics_state_obj_refs[name] = self.n
            self._out(state_dict)
            self._out(&#34;endobj&#34;)

    def _put_resource_dict(self):
        self.offsets[2] = len(self.buffer)
        self._out(&#34;2 0 obj&#34;)
        self._out(&#34;&lt;&lt;&#34;)

        # From section 10.1, &#34;Procedure Sets&#34;, of PDF 1.7 spec:
        # &gt; Beginning with PDF 1.4, this feature is considered obsolete.
        # &gt; For compatibility with existing consumer applications,
        # &gt; PDF producer applications should continue to specify procedure sets
        # &gt; (preferably, all of those listed in Table 10.1).
        self._out(&#34;/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]&#34;)
        self._out(&#34;/Font &lt;&lt;&#34;)
        font_ids = [(x[&#34;i&#34;], x[&#34;n&#34;]) for x in self.fpdf.fonts.values()]
        font_ids.sort()
        for idx, n in font_ids:
            self._out(f&#34;/F{idx} {pdf_ref(n)}&#34;)
        self._out(&#34;&gt;&gt;&#34;)

        # if self.images: [TODO] uncomment this &amp; indent the next 3 lines in order to save 15 bytes / page without image
        self._put_xobjects()

        if self.fpdf._drawing_graphics_state_registry:
            self._put_graphics_state_refs()

        self._out(&#34;&gt;&gt;&#34;)
        self._out(&#34;endobj&#34;)

    def _put_xobjects(self):
        self._out(&#34;/XObject &lt;&lt;&#34;)
        img_ids = [
            (img_info[&#34;i&#34;], img_info[&#34;n&#34;])
            for img_info in self.fpdf.images.values()
            if img_info[&#34;usages&#34;]
        ]
        img_ids.sort()
        for idx, n in img_ids:
            self._out(f&#34;/I{idx} {pdf_ref(n)}&#34;)
        self._out(&#34;&gt;&gt;&#34;)

    def _put_graphics_state_refs(self):
        assert (
            self._graphics_state_obj_refs is not None
        ), &#34;Graphics state objects refs must have been generated&#34;
        self._out(&#34;/ExtGState &lt;&lt;&#34;)
        for name, obj_id in self._graphics_state_obj_refs.items():
            self._out(f&#34;{render_pdf_primitive(name)} {pdf_ref(obj_id)}&#34;)
        self._out(&#34;&gt;&gt;&#34;)

    def _put_structure_tree(self):
        &#34;Builds a Structure Hierarchy, including image alternate descriptions&#34;
        # This property is later used by _put_catalog to insert a reference to the StructTreeRoot:
        self._struct_tree_root_obj_id = self.n + 1
        self.fpdf.struct_builder.serialize(
            first_object_id=self._struct_tree_root_obj_id, output_producer=self
        )

    def _put_document_outline(self):
        # This property is later used by _put_catalog to insert a reference to the Outlines:
        self._outlines_obj_id = self.n + 1
        serialize_outline(
            self.fpdf._outline,
            first_object_id=self._outlines_obj_id,
            output_producer=self,
        )

    def _put_xmp_metadata(self):
        xpacket = f&#39;&lt;?xpacket begin=&#34;ï»¿&#34; id=&#34;W5M0MpCehiHzreSzNTczkc9d&#34;?&gt;\n{self.fpdf.xmp_metadata}\n&lt;?xpacket end=&#34;w&#34;?&gt;\n&#39;
        self._newobj()
        self._out(f&#34;&lt;&lt;/Type /Metadata /Subtype /XML /Length {len(xpacket)}&gt;&gt;&#34;)
        self._out(pdf_stream(xpacket))
        self._out(&#34;endobj&#34;)
        self._xmp_metadata_obj_id = self.n

    def _put_info(self):
        fpdf = self.fpdf
        info_d = {
            &#34;/Title&#34;: enclose_in_parens(getattr(fpdf, &#34;title&#34;, None)),
            &#34;/Subject&#34;: enclose_in_parens(getattr(fpdf, &#34;subject&#34;, None)),
            &#34;/Author&#34;: enclose_in_parens(getattr(fpdf, &#34;author&#34;, None)),
            &#34;/Keywords&#34;: enclose_in_parens(getattr(fpdf, &#34;keywords&#34;, None)),
            &#34;/Creator&#34;: enclose_in_parens(getattr(fpdf, &#34;creator&#34;, None)),
            &#34;/Producer&#34;: enclose_in_parens(getattr(fpdf, &#34;producer&#34;, None)),
        }
        if fpdf.creation_date:
            try:
                info_d[&#34;/CreationDate&#34;] = format_date(fpdf.creation_date, with_tz=True)
            except Exception as error:
                raise FPDFException(
                    f&#34;Could not format date: {fpdf.creation_date}&#34;
                ) from error
        obj_id = self._newobj()
        self._out(&#34;&lt;&lt;&#34;)
        self._out(pdf_dict(info_d, open_dict=&#34;&#34;, close_dict=&#34;&#34;, has_empty_fields=True))
        self._out(&#34;&gt;&gt;&#34;)
        self._out(&#34;endobj&#34;)
        return obj_id

    def _put_catalog(self, sig_annotation_obj_id=None):
        fpdf = self.fpdf
        obj_id = self._newobj()
        self._out(&#34;&lt;&lt;&#34;)

        catalog_d = {
            &#34;/Type&#34;: &#34;/Catalog&#34;,
            # Pages is always the 1st object of the document, cf. _put_pages:
            &#34;/Pages&#34;: pdf_ref(1),
        }
        lang = enclose_in_parens(getattr(fpdf, &#34;lang&#34;, None))
        if lang:
            catalog_d[&#34;/Lang&#34;] = lang
        if sig_annotation_obj_id:
            flags = SignatureFlag.SIGNATURES_EXIST + SignatureFlag.APPEND_ONLY
            self._out(
                f&#34;/AcroForm &lt;&lt;/Fields [{sig_annotation_obj_id} 0 R] /SigFlags {flags}&gt;&gt;&#34;
            )

        if fpdf.zoom_mode in ZOOM_CONFIGS:
            zoom_config = [
                pdf_ref(3),  # reference to object ID of the 1st page
                *ZOOM_CONFIGS[fpdf.zoom_mode],
            ]
        else:  # zoom_mode is a number, not one of the allowed strings:
            zoom_config = [&#34;/XYZ&#34;, &#34;null&#34;, &#34;null&#34;, str(fpdf.zoom_mode / 100)]
        catalog_d[&#34;/OpenAction&#34;] = pdf_list(zoom_config)

        if fpdf.page_layout:
            catalog_d[&#34;/PageLayout&#34;] = fpdf.page_layout.value.pdf_repr()
        if fpdf.page_mode:
            catalog_d[&#34;/PageMode&#34;] = fpdf.page_mode.value.pdf_repr()
        if fpdf.viewer_preferences:
            catalog_d[&#34;/ViewerPreferences&#34;] = fpdf.viewer_preferences.serialize()
        assert (
            self._xmp_metadata_obj_id is not None
        ), &#34;ID of XMP metadata PDF object must be known&#34;
        if self._xmp_metadata_obj_id:
            catalog_d[&#34;/Metadata&#34;] = pdf_ref(self._xmp_metadata_obj_id)
        assert (
            self._struct_tree_root_obj_id is not None
        ), &#34;ID of root PDF object of the Structure Tree must be known&#34;
        if self._struct_tree_root_obj_id:
            catalog_d[&#34;/MarkInfo&#34;] = pdf_dict({&#34;/Marked&#34;: &#34;true&#34;})
            catalog_d[&#34;/StructTreeRoot&#34;] = pdf_ref(self._struct_tree_root_obj_id)
        assert (
            self._outlines_obj_id is not None
        ), &#34;ID of Outlines PDF object must be known&#34;
        if self._outlines_obj_id:
            catalog_d[&#34;/Outlines&#34;] = pdf_ref(self._outlines_obj_id)
        assert (
            self._embedded_files_per_pdf_ref is not None
        ), &#34;ID of Embedded files must be known&#34;
        if self._embedded_files_per_pdf_ref:
            file_spec_names = [
                f&#34;{enclose_in_parens(file.basename)} {file.file_spec(pdf_ref)}&#34;
                for pdf_ref, file in self._embedded_files_per_pdf_ref.items()
            ]
            catalog_d[&#34;/Names&#34;] = pdf_dict(
                {&#34;/EmbeddedFiles&#34;: pdf_dict({&#34;/Names&#34;: pdf_list(file_spec_names)})}
            )

        self._out(pdf_dict(catalog_d, open_dict=&#34;&#34;, close_dict=&#34;&#34;))
        self._out(&#34;&gt;&gt;&#34;)
        self._out(&#34;endobj&#34;)
        return obj_id

    def _put_trailer(self, info_obj_id, catalog_obj_id, startxref):
        self._out(&#34;trailer&#34;)
        self._out(&#34;&lt;&lt;&#34;)
        self._out(f&#34;/Size {self.n + 1}&#34;)
        self._out(f&#34;/Root {pdf_ref(catalog_obj_id)}&#34;)
        self._out(f&#34;/Info {pdf_ref(info_obj_id)}&#34;)
        file_id = self.fpdf.file_id(self.buffer, self.fpdf.creation_date)
        if file_id:
            self._out(f&#34;/ID [{file_id}]&#34;)
        self._out(&#34;&gt;&gt;&#34;)
        self._out(&#34;startxref&#34;)
        self._out(startxref)

    @contextmanager
    def _trace_size(self, label):
        prev_size = len(self.buffer)
        yield
        LOGGER.debug(&#34;- %s.size: %s&#34;, label, _sizeof_fmt(len(self.buffer) - prev_size))


def serialize_annot(annot, fpdf, embedded_files_per_pdf_ref=None):
    &#34;Convert this object dictionnary to a string&#34;
    rect = (
        f&#34;{annot.x:.2f} {annot.y:.2f} &#34;
        f&#34;{annot.x + annot.width:.2f} {annot.y - annot.height:.2f}&#34;
    )

    out = (
        f&#34;&lt;&lt;/Type /Annot /Subtype /{annot.type}&#34;
        f&#34; /Rect [{rect}] /Border [0 0 {annot.border_width}]&#34;
    )

    if annot.field_type:
        out += f&#34; /FT /{annot.field_type}&#34;

    if annot.value:
        out += f&#34; /V {annot.value.serialize()}&#34;

    if annot.flags:
        out += f&#34; /F {sum(annot.flags)}&#34;

    if annot.contents:
        out += f&#34; /Contents {enclose_in_parens(annot.contents)}&#34;

    if annot.action:
        out += f&#34; /A {annot.action.dict_as_string()}&#34;

    if annot.link:
        if isinstance(annot.link, str):
            out += f&#34; /A &lt;&lt;/S /URI /URI {enclose_in_parens(annot.link)}&gt;&gt;&#34;
        else:  # Dest type ending of annotation entry
            assert (
                annot.link in fpdf.links
            ), f&#34;Link with an invalid index: {annot.link} (doc #links={len(fpdf.links)})&#34;
            out += f&#34; /Dest {fpdf.links[annot.link].as_str(fpdf)}&#34;

    if annot.color:
        # pylint: disable=unsubscriptable-object
        out += f&#34; /C [{annot.color[0]} {annot.color[1]} {annot.color[2]}]&#34;

    if annot.title:
        out += f&#34; /T ({escape_parens(annot.title)})&#34;

    if annot.modification_time:
        out += f&#34; /M {format_date(annot.modification_time)}&#34;

    if annot.quad_points:
        # pylint: disable=not-an-iterable
        quad_points = pdf_list(f&#34;{quad_point:.2f}&#34; for quad_point in annot.quad_points)
        out += f&#34; /QuadPoints {quad_points}&#34;

    if annot.page:
        out += f&#34; /P {pdf_ref(object_id_for_page(annot.page))}&#34;

    if annot.name:
        out += f&#34; /Name {annot.name.value.pdf_repr()}&#34;

    if annot.ink_list:
        ink_list = pdf_list(f&#34;{coord:.2f}&#34; for coord in annot.ink_list)
        out += f&#34; /InkList [{ink_list}]&#34;

    if annot.embedded_file_name:
        # pylint: disable=protected-access
        assert (
            embedded_files_per_pdf_ref
        ), &#34;_build_embedded_files_per_pdf_ref() must be called beforehand to know PDF IDs of /EmbeddedFile objects&#34;
        embedded_file_ref, embedded_file = next(
            (file_ref, file)
            for file_ref, file in embedded_files_per_pdf_ref.items()
            if file.basename == annot.embedded_file_name
        )
        out += f&#34; /FS {embedded_file.file_spec(embedded_file_ref)}&#34;

    return out + &#34;&gt;&gt;&#34;


def _put_TT_font_widths(font, maxUni):
    rangeid = 0
    range_ = {}
    range_interval = {}
    prevcid = -2
    prevwidth = -1
    interval = False
    startcid = 1
    cwlen = maxUni + 1

    # for each character
    subset = font[&#34;subset&#34;].dict()
    for cid in range(startcid, cwlen):
        char_width = font[&#34;cw&#34;][cid]
        if &#34;dw&#34; not in font or (font[&#34;dw&#34;] and char_width != font[&#34;dw&#34;]):
            cid_mapped = subset.get(cid)
            if cid_mapped is None:
                continue
            if cid_mapped == (prevcid + 1):
                if char_width == prevwidth:
                    if char_width == range_[rangeid][0]:
                        range_.setdefault(rangeid, []).append(char_width)
                    else:
                        range_[rangeid].pop()
                        # new range
                        rangeid = prevcid
                        range_[rangeid] = [prevwidth, char_width]
                    interval = True
                    range_interval[rangeid] = True
                else:
                    if interval:
                        # new range
                        rangeid = cid_mapped
                        range_[rangeid] = [char_width]
                    else:
                        range_[rangeid].append(char_width)
                    interval = False
            else:
                rangeid = cid_mapped
                range_[rangeid] = [char_width]
                interval = False
            prevcid = cid_mapped
            prevwidth = char_width
    prevk = -1
    nextk = -1
    prevint = False

    ri = range_interval
    for k, ws in sorted(range_.items()):
        cws = len(ws)
        if k == nextk and not prevint and (k not in ri or cws &lt; 3):
            if k in ri:
                del ri[k]
            range_[prevk] = range_[prevk] + range_[k]
            del range_[k]
        else:
            prevk = k
        nextk = k + cws
        if k in ri:
            prevint = cws &gt; 3
            del ri[k]
            nextk -= 1
        else:
            prevint = False
    w = []
    for k, ws in sorted(range_.items()):
        if len(set(ws)) == 1:
            w.append(f&#34; {k} {k + len(ws) - 1} {ws[0]}&#34;)
        else:
            w.append(f&#34; {k} [ {&#39; &#39;.join(str(int(h)) for h in ws)} ]\n&#34;)
    return f&#34;/W [{&#39;&#39;.join(w)}]&#34;


def _sizeof_fmt(num, suffix=&#34;B&#34;):
    # Recipe from: https://stackoverflow.com/a/1094933/636849
    for unit in [&#34;&#34;, &#34;Ki&#34;, &#34;Mi&#34;, &#34;Gi&#34;, &#34;Ti&#34;, &#34;Pi&#34;, &#34;Ei&#34;, &#34;Zi&#34;]:
        if abs(num) &lt; 1024:
            return f&#34;{num:3.1f}{unit}{suffix}&#34;
        num /= 1024
    return f&#34;{num:.1f}Yi{suffix}&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="fpdf.output.serialize_annot"><code class="name flex">
<span>def <span class="ident">serialize_annot</span></span>(<span>annot, fpdf, embedded_files_per_pdf_ref=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert this object dictionnary to a string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialize_annot(annot, fpdf, embedded_files_per_pdf_ref=None):
    &#34;Convert this object dictionnary to a string&#34;
    rect = (
        f&#34;{annot.x:.2f} {annot.y:.2f} &#34;
        f&#34;{annot.x + annot.width:.2f} {annot.y - annot.height:.2f}&#34;
    )

    out = (
        f&#34;&lt;&lt;/Type /Annot /Subtype /{annot.type}&#34;
        f&#34; /Rect [{rect}] /Border [0 0 {annot.border_width}]&#34;
    )

    if annot.field_type:
        out += f&#34; /FT /{annot.field_type}&#34;

    if annot.value:
        out += f&#34; /V {annot.value.serialize()}&#34;

    if annot.flags:
        out += f&#34; /F {sum(annot.flags)}&#34;

    if annot.contents:
        out += f&#34; /Contents {enclose_in_parens(annot.contents)}&#34;

    if annot.action:
        out += f&#34; /A {annot.action.dict_as_string()}&#34;

    if annot.link:
        if isinstance(annot.link, str):
            out += f&#34; /A &lt;&lt;/S /URI /URI {enclose_in_parens(annot.link)}&gt;&gt;&#34;
        else:  # Dest type ending of annotation entry
            assert (
                annot.link in fpdf.links
            ), f&#34;Link with an invalid index: {annot.link} (doc #links={len(fpdf.links)})&#34;
            out += f&#34; /Dest {fpdf.links[annot.link].as_str(fpdf)}&#34;

    if annot.color:
        # pylint: disable=unsubscriptable-object
        out += f&#34; /C [{annot.color[0]} {annot.color[1]} {annot.color[2]}]&#34;

    if annot.title:
        out += f&#34; /T ({escape_parens(annot.title)})&#34;

    if annot.modification_time:
        out += f&#34; /M {format_date(annot.modification_time)}&#34;

    if annot.quad_points:
        # pylint: disable=not-an-iterable
        quad_points = pdf_list(f&#34;{quad_point:.2f}&#34; for quad_point in annot.quad_points)
        out += f&#34; /QuadPoints {quad_points}&#34;

    if annot.page:
        out += f&#34; /P {pdf_ref(object_id_for_page(annot.page))}&#34;

    if annot.name:
        out += f&#34; /Name {annot.name.value.pdf_repr()}&#34;

    if annot.ink_list:
        ink_list = pdf_list(f&#34;{coord:.2f}&#34; for coord in annot.ink_list)
        out += f&#34; /InkList [{ink_list}]&#34;

    if annot.embedded_file_name:
        # pylint: disable=protected-access
        assert (
            embedded_files_per_pdf_ref
        ), &#34;_build_embedded_files_per_pdf_ref() must be called beforehand to know PDF IDs of /EmbeddedFile objects&#34;
        embedded_file_ref, embedded_file = next(
            (file_ref, file)
            for file_ref, file in embedded_files_per_pdf_ref.items()
            if file.basename == annot.embedded_file_name
        )
        out += f&#34; /FS {embedded_file.file_spec(embedded_file_ref)}&#34;

    return out + &#34;&gt;&gt;&#34;</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fpdf.output.OutputProducer"><code class="flex name class">
<span>class <span class="ident">OutputProducer</span></span>
<span>(</span><span>fpdf)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates the final bytearray representing the PDF document, based on a FPDF instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OutputProducer:
    &#34;Generates the final bytearray representing the PDF document, based on a FPDF instance.&#34;

    def __init__(self, fpdf):
        self.fpdf = fpdf
        self.buffer = bytearray()  # resulting output buffer
        # array of PDF object offsets in self.buffer, used to build the xref table:
        self.offsets = {}
        self.n = 2  # current PDF object number
        self._graphics_state_obj_refs = None
        self._embedded_files_per_pdf_ref = None
        # Truthy only if a Structure Tree is added to the document:
        self._struct_tree_root_obj_id = None
        # Truthy only if an Outline is added to the document:
        self._outlines_obj_id = None
        # Truthy only if XMP metadata is added to the document:
        self._xmp_metadata_obj_id = None

    def bufferize(self):
        &#34;&#34;&#34;
        This operation alters the target FPDF instance
        through calls to ._insert_table_of_contents(), ._substitute_page_number(),
        _set_min_pdf_version() &amp; _final_pdf_version()
        &#34;&#34;&#34;
        # * PDF object 1 is always the pages root
        # * PDF object 2 is always the resources dictionary
        # Those objects are not inserted first in the document though
        LOGGER.debug(&#34;Final doc sections size summary:&#34;)
        fpdf = self.fpdf
        with self._trace_size(&#34;header&#34;):
            self._out(f&#34;%PDF-{fpdf._final_pdf_version()}&#34;)
        self._build_embedded_files_per_pdf_ref()
        # It is important that pages are the first PDF objects inserted in the document,
        # followed immediately by annotations: some parts of fpdf2 currently rely on that
        # order of insertion (e.g. util.object_id_for_page):
        with self._trace_size(&#34;pages&#34;):
            self._put_pages()
        with self._trace_size(&#34;annotations_objects&#34;):
            sig_annotation_obj_id = self._put_annotations_as_objects()
        with self._trace_size(&#34;embedded_files&#34;):
            self._put_embedded_files()
        self._put_resources()  # trace_size is performed inside
        if not fpdf.struct_builder.empty():
            with self._trace_size(&#34;structure_tree&#34;):
                self._put_structure_tree()
        else:
            self._struct_tree_root_obj_id = False
        if fpdf._outline:
            with self._trace_size(&#34;document_outline&#34;):
                self._put_document_outline()
        else:
            self._outlines_obj_id = False
        if fpdf.xmp_metadata:
            self._put_xmp_metadata()
        else:
            self._xmp_metadata_obj_id = False
        with self._trace_size(&#34;info&#34;):
            info_obj_id = self._put_info()
        with self._trace_size(&#34;catalog&#34;):
            catalog_obj_id = self._put_catalog(sig_annotation_obj_id)
        with self._trace_size(&#34;xref&#34;):  #  cross-reference table
            startxref = len(self.buffer)
            self._out(&#34;xref&#34;)
            self._out(f&#34;0 {self.n + 1}&#34;)
            self._out(&#34;0000000000 65535 f &#34;)
            for i in range(1, self.n + 1):
                self._out(f&#34;{self.offsets[i]:010} 00000 n &#34;)
        with self._trace_size(&#34;trailer&#34;):
            self._put_trailer(info_obj_id, catalog_obj_id, startxref)
        self._out(&#34;%%EOF&#34;)
        if fpdf._sign_key:
            self.buffer = sign_content(
                signer,
                self.buffer,
                fpdf._sign_key,
                fpdf._sign_cert,
                fpdf._sign_extra_certs,
                fpdf._sign_hashalgo,
                fpdf._sign_time,
            )
        return self.buffer

    def _out(self, s):
        if not isinstance(s, bytes):
            if not isinstance(s, str):
                s = str(s)
            s = s.encode(&#34;latin1&#34;)
        self.buffer += s + b&#34;\n&#34;

    def _newobj(self):
        &#34;Begin a new PDF object&#34;
        self.n += 1
        self.offsets[self.n] = len(self.buffer)
        self._out(f&#34;{self.n} 0 obj&#34;)
        return self.n

    def _build_embedded_files_per_pdf_ref(self):
        assert self._embedded_files_per_pdf_ref is None
        fpdf = self.fpdf
        self._embedded_files_per_pdf_ref = {}
        first_annot_obj_id = object_id_for_page(fpdf.pages_count) + 2
        annotations_count = sum(
            len(page_annots_as_obj)
            for page_annots_as_obj in fpdf.annots_as_obj.values()
        )
        for n, embedd_file in enumerate(
            fpdf.embedded_files, start=first_annot_obj_id + annotations_count
        ):
            self._embedded_files_per_pdf_ref[pdf_ref(n)] = embedd_file

    def _put_pages(self):
        fpdf = self.fpdf
        if fpdf._toc_placeholder:
            fpdf._insert_table_of_contents()
        if fpdf.str_alias_nb_pages:
            fpdf._substitute_page_number()
        if fpdf.def_orientation == &#34;P&#34;:
            dw_pt = fpdf.dw_pt
            dh_pt = fpdf.dh_pt
        else:
            dw_pt = fpdf.dh_pt
            dh_pt = fpdf.dw_pt
        compression_filter = &#34;/Filter /FlateDecode &#34; if fpdf.compress else &#34;&#34;

        # The Annotations embedded as PDF objects
        # are added to the document just after all the pages,
        # hence we can deduce their object IDs:
        annot_obj_id = object_id_for_page(fpdf.pages_count) + 2

        for n in range(1, fpdf.pages_count + 1):
            # Page
            self._newobj()
            self._out(&#34;&lt;&lt;/Type /Page&#34;)
            self._out(f&#34;/Parent {pdf_ref(1)}&#34;)
            page = fpdf.pages[n]
            if page[&#34;duration&#34;]:
                self._out(f&#34;/Dur {page[&#39;duration&#39;]}&#34;)
            if page[&#34;transition&#34;]:
                self._out(f&#34;/Trans {page[&#39;transition&#39;].dict_as_string()}&#34;)
            w_pt, h_pt = page[&#34;w_pt&#34;], page[&#34;h_pt&#34;]
            if w_pt != dw_pt or h_pt != dh_pt:
                self._out(f&#34;/MediaBox [0 0 {w_pt:.2f} {h_pt:.2f}]&#34;)
            self._out(f&#34;/Resources {pdf_ref(2)}&#34;)
            annot_obj_id = self._put_page_annotations(n, annot_obj_id)
            if fpdf.pdf_version &gt; &#34;1.3&#34;:
                self._out(&#34;/Group &lt;&lt;/Type /Group /S /Transparency /CS /DeviceRGB&gt;&gt;&#34;)
            spid = fpdf._struct_parents_id_per_page.get(self.n)
            if spid is not None:
                self._out(f&#34;/StructParents {spid}&#34;)
            self._out(f&#34;/Contents {pdf_ref(self.n + 1)}&gt;&gt;&#34;)
            self._out(&#34;endobj&#34;)

            # Page content
            content = page[&#34;content&#34;]
            p = zlib.compress(content) if fpdf.compress else content
            self._newobj()
            self._out(f&#34;&lt;&lt;{compression_filter}/Length {len(p)}&gt;&gt;&#34;)
            self._out(pdf_stream(p))
            self._out(&#34;endobj&#34;)
        # Pages root
        self.offsets[1] = len(self.buffer)
        self._out(&#34;1 0 obj&#34;)
        self._out(&#34;&lt;&lt;/Type /Pages&#34;)
        self._out(
            &#34;/Kids [&#34;
            + &#34; &#34;.join(
                pdf_ref(object_id_for_page(page))
                for page in range(1, fpdf.pages_count + 1)
            )
            + &#34;]&#34;
        )
        self._out(f&#34;/Count {fpdf.pages_count}&#34;)
        self._out(f&#34;/MediaBox [0 0 {dw_pt:.2f} {dh_pt:.2f}]&#34;)
        self._out(&#34;&gt;&gt;&#34;)
        self._out(&#34;endobj&#34;)

    def _put_page_annotations(self, page_number, annot_obj_id):
        fpdf = self.fpdf
        page_annots = fpdf.annots[page_number]
        page_annots_as_obj = fpdf.annots_as_obj[page_number]
        if page_annots or page_annots_as_obj:
            # Annotations, e.g. links:
            annots = &#34;&#34;
            for annot in page_annots:
                annots += serialize_annot(annot, fpdf, self._embedded_files_per_pdf_ref)
                if annot.quad_points:
                    # This won&#39;t alter the PDF header, that has already been rendered,
                    # but can trigger the insertion of a /Page /Group by _put_pages:
                    fpdf._set_min_pdf_version(&#34;1.6&#34;)
            if page_annots and page_annots_as_obj:
                annots += &#34; &#34;
            annots += &#34; &#34;.join(
                f&#34;{annot_obj_id + i} 0 R&#34; for i in range(len(page_annots_as_obj))
            )
            annot_obj_id += len(page_annots_as_obj)
            self._out(f&#34;/Annots [{annots}]&#34;)
        return annot_obj_id

    def _put_annotations_as_objects(self):
        fpdf = self.fpdf
        sig_annotation_obj_id = None
        # The following code inserts annotations in the order
        # they have been inserted in the pages / .annots_as_obj dict;
        # this relies on a property of Python dicts since v3.7:
        for page_annots_as_obj in fpdf.annots_as_obj.values():
            for annot in page_annots_as_obj:
                self._newobj()
                self._out(
                    serialize_annot(annot, fpdf, self._embedded_files_per_pdf_ref)
                )
                self._out(&#34;endobj&#34;)
                if isinstance(annot.value, Signature):
                    sig_annotation_obj_id = self.n
        return sig_annotation_obj_id

    def _put_embedded_files(self):
        for embedd_file in self.fpdf.embedded_files:
            stream_dict = {
                &#34;/Type&#34;: &#34;/EmbeddedFile&#34;,
            }
            stream_content = embedd_file.bytes
            if embedd_file.compress:
                stream_dict[&#34;/Filter&#34;] = &#34;/FlateDecode&#34;
                stream_content = zlib.compress(stream_content)
            stream_dict[&#34;/Length&#34;] = len(stream_content)
            params = {
                &#34;/Size&#34;: len(embedd_file.bytes),
            }
            if embedd_file.creation_date:
                params[&#34;/CreationDate&#34;] = format_date(
                    embedd_file.creation_date, with_tz=True
                )
            if embedd_file.modification_date:
                params[&#34;/ModDate&#34;] = format_date(
                    embedd_file.modification_date, with_tz=True
                )
            if embedd_file.checksum:
                file_hash = hashlib.new(&#34;md5&#34;, usedforsecurity=False)
                file_hash.update(stream_content)
                hash_hex = file_hash.hexdigest()
                params[&#34;/CheckSum&#34;] = f&#34;&lt;{hash_hex}&gt;&#34;
            stream_dict[&#34;/Params&#34;] = pdf_dict(params)
            self._newobj()
            self._out(pdf_dict(stream_dict))
            self._out(pdf_stream(stream_content))
            self._out(&#34;endobj&#34;)
            assert self._embedded_files_per_pdf_ref[pdf_ref(self.n)] == embedd_file

    def _put_resources(self):
        with self._trace_size(&#34;resources.fonts&#34;):
            self._put_fonts()
        with self._trace_size(&#34;resources.images&#34;):
            self._put_images()
        with self._trace_size(&#34;resources.gfxstate&#34;):
            self._put_graphics_state_dicts()

        # Resource dictionary
        with self._trace_size(&#34;resources.dict&#34;):
            self._put_resource_dict()

    def _put_fonts(self):
        fpdf = self.fpdf
        flist = [(x[1][&#34;i&#34;], x[0], x[1]) for x in fpdf.fonts.items()]
        flist.sort()
        for _, font_name, font in flist:
            fpdf.fonts[font_name][&#34;n&#34;] = self.n + 1
            # Standard font
            if font[&#34;type&#34;] == &#34;core&#34;:
                self._newobj()
                self._out(&#34;&lt;&lt;/Type /Font&#34;)
                self._out(f&#34;/BaseFont /{font[&#39;name&#39;]}&#34;)
                self._out(&#34;/Subtype /Type1&#34;)
                if font[&#34;name&#34;] not in (&#34;Symbol&#34;, &#34;ZapfDingbats&#34;):
                    self._out(&#34;/Encoding /WinAnsiEncoding&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(&#34;endobj&#34;)
            elif font[&#34;type&#34;] == &#34;TTF&#34;:
                fontname = f&#34;MPDFAA+{font[&#39;name&#39;]}&#34;

                # unicode_char -&gt; new_code_char map for chars embedded in the PDF
                uni_to_new_code_char = font[&#34;subset&#34;].dict()

                # why we delete 0-element?
                del uni_to_new_code_char[0]

                # ---- FONTTOOLS SUBSETTER ----
                # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
                # if we leave recalcTimestamp=True the tests will break every time
                fonttools_font = ttLib.TTFont(
                    file=font[&#34;ttffile&#34;], recalcTimestamp=False
                )

                # 1. get all glyphs in PDF
                cmap = fonttools_font[&#34;cmap&#34;].getBestCmap()
                glyph_names = [
                    cmap[unicode] for unicode in uni_to_new_code_char if unicode in cmap
                ]

                # 2. make a subset
                # notdef_outline=True means that keeps the white box for the .notdef glyph
                # recommended_glyphs=True means that adds the .notdef, .null, CR, and space glyphs
                options = ftsubset.Options(notdef_outline=True, recommended_glyphs=True)
                # dropping the tables previous dropped in the old ttfonts.py file #issue 418
                options.drop_tables += [&#34;GDEF&#34;, &#34;GSUB&#34;, &#34;GPOS&#34;, &#34;MATH&#34;, &#34;hdmx&#34;]
                subsetter = ftsubset.Subsetter(options)
                subsetter.populate(glyphs=glyph_names)
                subsetter.subset(fonttools_font)

                # 3. make codeToGlyph
                # is a map Character_ID -&gt; Glyph_ID
                # it&#39;s used for associating glyphs to new codes
                # this basically takes the old code of the character
                # take the glyph associated with it
                # and then associate to the new code the glyph associated with the old code
                code_to_glyph = {}
                for code, new_code_mapped in uni_to_new_code_char.items():
                    if code in cmap:
                        glyph_name = cmap[code]
                        code_to_glyph[new_code_mapped] = fonttools_font.getGlyphID(
                            glyph_name
                        )
                    else:
                        # notdef is associated if no glyph was associated to the old code
                        # it&#39;s not necessary to do this, it seems to be done by default
                        code_to_glyph[new_code_mapped] = fonttools_font.getGlyphID(
                            &#34;.notdef&#34;
                        )

                # 4. return the ttfile
                output = BytesIO()
                fonttools_font.save(output)

                output.seek(0)
                ttfontstream = output.read()
                ttfontsize = len(ttfontstream)
                fontstream = zlib.compress(ttfontstream)

                # Type0 Font
                # A composite font - a font composed of other fonts,
                # organized hierarchically
                self._newobj()
                self._out(&#34;&lt;&lt;/Type /Font&#34;)
                self._out(&#34;/Subtype /Type0&#34;)
                self._out(f&#34;/BaseFont /{fontname}&#34;)
                self._out(&#34;/Encoding /Identity-H&#34;)
                self._out(f&#34;/DescendantFonts [{pdf_ref(self.n + 1)}]&#34;)
                self._out(f&#34;/ToUnicode {pdf_ref(self.n + 2)}&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(&#34;endobj&#34;)

                # CIDFontType2
                # A CIDFont whose glyph descriptions are based on
                # TrueType font technology
                self._newobj()
                self._out(&#34;&lt;&lt;/Type /Font&#34;)
                self._out(&#34;/Subtype /CIDFontType2&#34;)
                self._out(f&#34;/BaseFont /{fontname}&#34;)
                self._out(f&#34;/CIDSystemInfo {pdf_ref(self.n + 2)}&#34;)
                self._out(f&#34;/FontDescriptor {pdf_ref(self.n + 3)}&#34;)
                if font[&#34;desc&#34;].get(&#34;MissingWidth&#34;):
                    self._out(f&#34;/DW {font[&#39;desc&#39;][&#39;MissingWidth&#39;]}&#34;)
                self._out(_put_TT_font_widths(font, max(uni_to_new_code_char)))
                self._out(f&#34;/CIDToGIDMap {pdf_ref(self.n + 4)}&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(&#34;endobj&#34;)

                # bfChar
                # This table informs the PDF reader about the unicode
                # character that each used 16-bit code belongs to. It
                # allows searching the file and copying text from it.
                bfChar = []
                uni_to_new_code_char = font[&#34;subset&#34;].dict()
                for code in uni_to_new_code_char:
                    code_mapped = uni_to_new_code_char.get(code)
                    if code &gt; 0xFFFF:
                        # Calculate surrogate pair
                        code_high = 0xD800 | (code - 0x10000) &gt;&gt; 10
                        code_low = 0xDC00 | (code &amp; 0x3FF)
                        bfChar.append(
                            f&#34;&lt;{code_mapped:04X}&gt; &lt;{code_high:04X}{code_low:04X}&gt;\n&#34;
                        )
                    else:
                        bfChar.append(f&#34;&lt;{code_mapped:04X}&gt; &lt;{code:04X}&gt;\n&#34;)

                # ToUnicode
                self._newobj()
                toUni = (
                    &#34;/CIDInit /ProcSet findresource begin\n&#34;
                    &#34;12 dict begin\n&#34;
                    &#34;begincmap\n&#34;
                    &#34;/CIDSystemInfo\n&#34;
                    &#34;&lt;&lt;/Registry (Adobe)\n&#34;
                    &#34;/Ordering (UCS)\n&#34;
                    &#34;/Supplement 0\n&#34;
                    &#34;&gt;&gt; def\n&#34;
                    &#34;/CMapName /Adobe-Identity-UCS def\n&#34;
                    &#34;/CMapType 2 def\n&#34;
                    &#34;1 begincodespacerange\n&#34;
                    &#34;&lt;0000&gt; &lt;FFFF&gt;\n&#34;
                    &#34;endcodespacerange\n&#34;
                    f&#34;{len(bfChar)} beginbfchar\n&#34;
                    f&#34;{&#39;&#39;.join(bfChar)}&#34;
                    &#34;endbfchar\n&#34;
                    &#34;endcmap\n&#34;
                    &#34;CMapName currentdict /CMap defineresource pop\n&#34;
                    &#34;end\n&#34;
                    &#34;end&#34;
                )
                self._out(f&#34;&lt;&lt;/Length {len(toUni)}&gt;&gt;&#34;)
                self._out(pdf_stream(toUni))
                self._out(&#34;endobj&#34;)

                # CIDSystemInfo dictionary
                self._newobj()
                self._out(&#34;&lt;&lt;/Registry (Adobe)&#34;)
                self._out(&#34;/Ordering (UCS)&#34;)
                self._out(&#34;/Supplement 0&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(&#34;endobj&#34;)

                # Font descriptor
                self._newobj()
                self._out(&#34;&lt;&lt;/Type /FontDescriptor&#34;)
                self._out(&#34;/FontName /&#34; + fontname)
                for key, value in font[&#34;desc&#34;].items():
                    self._out(f&#34; /{key} {value}&#34;)
                self._out(f&#34;/FontFile2 {pdf_ref(self.n + 2)}&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(&#34;endobj&#34;)

                # Embed CIDToGIDMap
                # A specification of the mapping from CIDs to glyph indices
                cid_to_gid_map = [&#34;\x00&#34;] * 256 * 256 * 2
                for cc, glyph in code_to_glyph.items():
                    cid_to_gid_map[cc * 2] = chr(glyph &gt;&gt; 8)
                    cid_to_gid_map[cc * 2 + 1] = chr(glyph &amp; 0xFF)
                cid_to_gid_map = &#34;&#34;.join(cid_to_gid_map)

                # manage binary data as latin1 until PEP461-like function is implemented
                cid_to_gid_map = zlib.compress(cid_to_gid_map.encode(&#34;latin1&#34;))

                self._newobj()
                self._out(f&#34;&lt;&lt;/Length {len(cid_to_gid_map)}&#34;)
                self._out(&#34;/Filter /FlateDecode&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(pdf_stream(cid_to_gid_map))
                self._out(&#34;endobj&#34;)

                # Font file
                self._newobj()
                self._out(f&#34;&lt;&lt;/Length {len(fontstream)}&#34;)
                self._out(&#34;/Filter /FlateDecode&#34;)
                self._out(f&#34;/Length1 {ttfontsize}&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(pdf_stream(fontstream))
                self._out(&#34;endobj&#34;)

    def _put_images(self):
        for img_info in sorted(
            self.fpdf.images.values(), key=lambda img_info: img_info[&#34;i&#34;]
        ):
            if img_info[&#34;usages&#34;] &gt; 0:
                self._put_image(img_info)

    def _put_image(self, info):
        if &#34;data&#34; not in info:
            return
        self._newobj()
        info[&#34;n&#34;] = self.n
        self._out(&#34;&lt;&lt;/Type /XObject&#34;)
        self._out(&#34;/Subtype /Image&#34;)
        self._out(f&#34;/Width {info[&#39;w&#39;]}&#34;)
        self._out(f&#34;/Height {info[&#39;h&#39;]}&#34;)

        if info[&#34;cs&#34;] == &#34;Indexed&#34;:
            palette_ref = (
                pdf_ref(self.n + 2)
                if self.fpdf.allow_images_transparency and &#34;smask&#34; in info
                else pdf_ref(self.n + 1)
            )
            self._out(
                f&#34;/ColorSpace [/Indexed /DeviceRGB &#34;
                f&#34;{len(info[&#39;pal&#39;]) // 3 - 1} {palette_ref}]&#34;
            )
        else:
            self._out(f&#34;/ColorSpace /{info[&#39;cs&#39;]}&#34;)
            if info[&#34;cs&#34;] == &#34;DeviceCMYK&#34;:
                self._out(&#34;/Decode [1 0 1 0 1 0 1 0]&#34;)

        self._out(f&#34;/BitsPerComponent {info[&#39;bpc&#39;]}&#34;)

        if &#34;f&#34; in info:
            self._out(f&#34;/Filter /{info[&#39;f&#39;]}&#34;)
        if &#34;dp&#34; in info:
            self._out(f&#34;/DecodeParms &lt;&lt;{info[&#39;dp&#39;]}&gt;&gt;&#34;)

        if &#34;trns&#34; in info and isinstance(info[&#34;trns&#34;], list):
            trns = &#34; &#34;.join(f&#34;{x} {x}&#34; for x in info[&#34;trns&#34;])
            self._out(f&#34;/Mask [{trns}]&#34;)

        if self.fpdf.allow_images_transparency and &#34;smask&#34; in info:
            self._out(f&#34;/SMask {pdf_ref(self.n + 1)}&#34;)

        self._out(f&#34;/Length {len(info[&#39;data&#39;])}&gt;&gt;&#34;)
        self._out(pdf_stream(info[&#34;data&#34;]))
        self._out(&#34;endobj&#34;)

        # Soft mask
        if self.fpdf.allow_images_transparency and &#34;smask&#34; in info:
            dp = f&#34;/Predictor 15 /Colors 1 /BitsPerComponent 8 /Columns {info[&#39;w&#39;]}&#34;
            smask = {
                &#34;w&#34;: info[&#34;w&#34;],
                &#34;h&#34;: info[&#34;h&#34;],
                &#34;cs&#34;: &#34;DeviceGray&#34;,
                &#34;bpc&#34;: 8,
                &#34;f&#34;: info[&#34;f&#34;],
                &#34;dp&#34;: dp,
                &#34;data&#34;: info[&#34;smask&#34;],
            }
            self._put_image(smask)

        # Palette
        if info[&#34;cs&#34;] == &#34;Indexed&#34;:
            self._newobj()
            if self.fpdf.compress:
                pal_filter, pal_data = (
                    &#34;/Filter /FlateDecode &#34;,
                    zlib.compress(info[&#34;pal&#34;]),
                )
            else:
                pal_filter, pal_data = (&#34;&#34;, info[&#34;pal&#34;])
            self._out(f&#34;&lt;&lt;{pal_filter}/Length {len(pal_data)}&gt;&gt;&#34;)
            self._out(pdf_stream(pal_data))
            self._out(&#34;endobj&#34;)

    def _put_graphics_state_dicts(self):
        self._graphics_state_obj_refs = OrderedDict()
        for state_dict, name in self.fpdf._drawing_graphics_state_registry.items():
            self._newobj()
            self._graphics_state_obj_refs[name] = self.n
            self._out(state_dict)
            self._out(&#34;endobj&#34;)

    def _put_resource_dict(self):
        self.offsets[2] = len(self.buffer)
        self._out(&#34;2 0 obj&#34;)
        self._out(&#34;&lt;&lt;&#34;)

        # From section 10.1, &#34;Procedure Sets&#34;, of PDF 1.7 spec:
        # &gt; Beginning with PDF 1.4, this feature is considered obsolete.
        # &gt; For compatibility with existing consumer applications,
        # &gt; PDF producer applications should continue to specify procedure sets
        # &gt; (preferably, all of those listed in Table 10.1).
        self._out(&#34;/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]&#34;)
        self._out(&#34;/Font &lt;&lt;&#34;)
        font_ids = [(x[&#34;i&#34;], x[&#34;n&#34;]) for x in self.fpdf.fonts.values()]
        font_ids.sort()
        for idx, n in font_ids:
            self._out(f&#34;/F{idx} {pdf_ref(n)}&#34;)
        self._out(&#34;&gt;&gt;&#34;)

        # if self.images: [TODO] uncomment this &amp; indent the next 3 lines in order to save 15 bytes / page without image
        self._put_xobjects()

        if self.fpdf._drawing_graphics_state_registry:
            self._put_graphics_state_refs()

        self._out(&#34;&gt;&gt;&#34;)
        self._out(&#34;endobj&#34;)

    def _put_xobjects(self):
        self._out(&#34;/XObject &lt;&lt;&#34;)
        img_ids = [
            (img_info[&#34;i&#34;], img_info[&#34;n&#34;])
            for img_info in self.fpdf.images.values()
            if img_info[&#34;usages&#34;]
        ]
        img_ids.sort()
        for idx, n in img_ids:
            self._out(f&#34;/I{idx} {pdf_ref(n)}&#34;)
        self._out(&#34;&gt;&gt;&#34;)

    def _put_graphics_state_refs(self):
        assert (
            self._graphics_state_obj_refs is not None
        ), &#34;Graphics state objects refs must have been generated&#34;
        self._out(&#34;/ExtGState &lt;&lt;&#34;)
        for name, obj_id in self._graphics_state_obj_refs.items():
            self._out(f&#34;{render_pdf_primitive(name)} {pdf_ref(obj_id)}&#34;)
        self._out(&#34;&gt;&gt;&#34;)

    def _put_structure_tree(self):
        &#34;Builds a Structure Hierarchy, including image alternate descriptions&#34;
        # This property is later used by _put_catalog to insert a reference to the StructTreeRoot:
        self._struct_tree_root_obj_id = self.n + 1
        self.fpdf.struct_builder.serialize(
            first_object_id=self._struct_tree_root_obj_id, output_producer=self
        )

    def _put_document_outline(self):
        # This property is later used by _put_catalog to insert a reference to the Outlines:
        self._outlines_obj_id = self.n + 1
        serialize_outline(
            self.fpdf._outline,
            first_object_id=self._outlines_obj_id,
            output_producer=self,
        )

    def _put_xmp_metadata(self):
        xpacket = f&#39;&lt;?xpacket begin=&#34;ï»¿&#34; id=&#34;W5M0MpCehiHzreSzNTczkc9d&#34;?&gt;\n{self.fpdf.xmp_metadata}\n&lt;?xpacket end=&#34;w&#34;?&gt;\n&#39;
        self._newobj()
        self._out(f&#34;&lt;&lt;/Type /Metadata /Subtype /XML /Length {len(xpacket)}&gt;&gt;&#34;)
        self._out(pdf_stream(xpacket))
        self._out(&#34;endobj&#34;)
        self._xmp_metadata_obj_id = self.n

    def _put_info(self):
        fpdf = self.fpdf
        info_d = {
            &#34;/Title&#34;: enclose_in_parens(getattr(fpdf, &#34;title&#34;, None)),
            &#34;/Subject&#34;: enclose_in_parens(getattr(fpdf, &#34;subject&#34;, None)),
            &#34;/Author&#34;: enclose_in_parens(getattr(fpdf, &#34;author&#34;, None)),
            &#34;/Keywords&#34;: enclose_in_parens(getattr(fpdf, &#34;keywords&#34;, None)),
            &#34;/Creator&#34;: enclose_in_parens(getattr(fpdf, &#34;creator&#34;, None)),
            &#34;/Producer&#34;: enclose_in_parens(getattr(fpdf, &#34;producer&#34;, None)),
        }
        if fpdf.creation_date:
            try:
                info_d[&#34;/CreationDate&#34;] = format_date(fpdf.creation_date, with_tz=True)
            except Exception as error:
                raise FPDFException(
                    f&#34;Could not format date: {fpdf.creation_date}&#34;
                ) from error
        obj_id = self._newobj()
        self._out(&#34;&lt;&lt;&#34;)
        self._out(pdf_dict(info_d, open_dict=&#34;&#34;, close_dict=&#34;&#34;, has_empty_fields=True))
        self._out(&#34;&gt;&gt;&#34;)
        self._out(&#34;endobj&#34;)
        return obj_id

    def _put_catalog(self, sig_annotation_obj_id=None):
        fpdf = self.fpdf
        obj_id = self._newobj()
        self._out(&#34;&lt;&lt;&#34;)

        catalog_d = {
            &#34;/Type&#34;: &#34;/Catalog&#34;,
            # Pages is always the 1st object of the document, cf. _put_pages:
            &#34;/Pages&#34;: pdf_ref(1),
        }
        lang = enclose_in_parens(getattr(fpdf, &#34;lang&#34;, None))
        if lang:
            catalog_d[&#34;/Lang&#34;] = lang
        if sig_annotation_obj_id:
            flags = SignatureFlag.SIGNATURES_EXIST + SignatureFlag.APPEND_ONLY
            self._out(
                f&#34;/AcroForm &lt;&lt;/Fields [{sig_annotation_obj_id} 0 R] /SigFlags {flags}&gt;&gt;&#34;
            )

        if fpdf.zoom_mode in ZOOM_CONFIGS:
            zoom_config = [
                pdf_ref(3),  # reference to object ID of the 1st page
                *ZOOM_CONFIGS[fpdf.zoom_mode],
            ]
        else:  # zoom_mode is a number, not one of the allowed strings:
            zoom_config = [&#34;/XYZ&#34;, &#34;null&#34;, &#34;null&#34;, str(fpdf.zoom_mode / 100)]
        catalog_d[&#34;/OpenAction&#34;] = pdf_list(zoom_config)

        if fpdf.page_layout:
            catalog_d[&#34;/PageLayout&#34;] = fpdf.page_layout.value.pdf_repr()
        if fpdf.page_mode:
            catalog_d[&#34;/PageMode&#34;] = fpdf.page_mode.value.pdf_repr()
        if fpdf.viewer_preferences:
            catalog_d[&#34;/ViewerPreferences&#34;] = fpdf.viewer_preferences.serialize()
        assert (
            self._xmp_metadata_obj_id is not None
        ), &#34;ID of XMP metadata PDF object must be known&#34;
        if self._xmp_metadata_obj_id:
            catalog_d[&#34;/Metadata&#34;] = pdf_ref(self._xmp_metadata_obj_id)
        assert (
            self._struct_tree_root_obj_id is not None
        ), &#34;ID of root PDF object of the Structure Tree must be known&#34;
        if self._struct_tree_root_obj_id:
            catalog_d[&#34;/MarkInfo&#34;] = pdf_dict({&#34;/Marked&#34;: &#34;true&#34;})
            catalog_d[&#34;/StructTreeRoot&#34;] = pdf_ref(self._struct_tree_root_obj_id)
        assert (
            self._outlines_obj_id is not None
        ), &#34;ID of Outlines PDF object must be known&#34;
        if self._outlines_obj_id:
            catalog_d[&#34;/Outlines&#34;] = pdf_ref(self._outlines_obj_id)
        assert (
            self._embedded_files_per_pdf_ref is not None
        ), &#34;ID of Embedded files must be known&#34;
        if self._embedded_files_per_pdf_ref:
            file_spec_names = [
                f&#34;{enclose_in_parens(file.basename)} {file.file_spec(pdf_ref)}&#34;
                for pdf_ref, file in self._embedded_files_per_pdf_ref.items()
            ]
            catalog_d[&#34;/Names&#34;] = pdf_dict(
                {&#34;/EmbeddedFiles&#34;: pdf_dict({&#34;/Names&#34;: pdf_list(file_spec_names)})}
            )

        self._out(pdf_dict(catalog_d, open_dict=&#34;&#34;, close_dict=&#34;&#34;))
        self._out(&#34;&gt;&gt;&#34;)
        self._out(&#34;endobj&#34;)
        return obj_id

    def _put_trailer(self, info_obj_id, catalog_obj_id, startxref):
        self._out(&#34;trailer&#34;)
        self._out(&#34;&lt;&lt;&#34;)
        self._out(f&#34;/Size {self.n + 1}&#34;)
        self._out(f&#34;/Root {pdf_ref(catalog_obj_id)}&#34;)
        self._out(f&#34;/Info {pdf_ref(info_obj_id)}&#34;)
        file_id = self.fpdf.file_id(self.buffer, self.fpdf.creation_date)
        if file_id:
            self._out(f&#34;/ID [{file_id}]&#34;)
        self._out(&#34;&gt;&gt;&#34;)
        self._out(&#34;startxref&#34;)
        self._out(startxref)

    @contextmanager
    def _trace_size(self, label):
        prev_size = len(self.buffer)
        yield
        LOGGER.debug(&#34;- %s.size: %s&#34;, label, _sizeof_fmt(len(self.buffer) - prev_size))</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="fpdf.output.OutputProducer.bufferize"><code class="name flex">
<span>def <span class="ident">bufferize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This operation alters the target FPDF instance
through calls to ._insert_table_of_contents(), ._substitute_page_number(),
_set_min_pdf_version() &amp; _final_pdf_version()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bufferize(self):
    &#34;&#34;&#34;
    This operation alters the target FPDF instance
    through calls to ._insert_table_of_contents(), ._substitute_page_number(),
    _set_min_pdf_version() &amp; _final_pdf_version()
    &#34;&#34;&#34;
    # * PDF object 1 is always the pages root
    # * PDF object 2 is always the resources dictionary
    # Those objects are not inserted first in the document though
    LOGGER.debug(&#34;Final doc sections size summary:&#34;)
    fpdf = self.fpdf
    with self._trace_size(&#34;header&#34;):
        self._out(f&#34;%PDF-{fpdf._final_pdf_version()}&#34;)
    self._build_embedded_files_per_pdf_ref()
    # It is important that pages are the first PDF objects inserted in the document,
    # followed immediately by annotations: some parts of fpdf2 currently rely on that
    # order of insertion (e.g. util.object_id_for_page):
    with self._trace_size(&#34;pages&#34;):
        self._put_pages()
    with self._trace_size(&#34;annotations_objects&#34;):
        sig_annotation_obj_id = self._put_annotations_as_objects()
    with self._trace_size(&#34;embedded_files&#34;):
        self._put_embedded_files()
    self._put_resources()  # trace_size is performed inside
    if not fpdf.struct_builder.empty():
        with self._trace_size(&#34;structure_tree&#34;):
            self._put_structure_tree()
    else:
        self._struct_tree_root_obj_id = False
    if fpdf._outline:
        with self._trace_size(&#34;document_outline&#34;):
            self._put_document_outline()
    else:
        self._outlines_obj_id = False
    if fpdf.xmp_metadata:
        self._put_xmp_metadata()
    else:
        self._xmp_metadata_obj_id = False
    with self._trace_size(&#34;info&#34;):
        info_obj_id = self._put_info()
    with self._trace_size(&#34;catalog&#34;):
        catalog_obj_id = self._put_catalog(sig_annotation_obj_id)
    with self._trace_size(&#34;xref&#34;):  #  cross-reference table
        startxref = len(self.buffer)
        self._out(&#34;xref&#34;)
        self._out(f&#34;0 {self.n + 1}&#34;)
        self._out(&#34;0000000000 65535 f &#34;)
        for i in range(1, self.n + 1):
            self._out(f&#34;{self.offsets[i]:010} 00000 n &#34;)
    with self._trace_size(&#34;trailer&#34;):
        self._put_trailer(info_obj_id, catalog_obj_id, startxref)
    self._out(&#34;%%EOF&#34;)
    if fpdf._sign_key:
        self.buffer = sign_content(
            signer,
            self.buffer,
            fpdf._sign_key,
            fpdf._sign_cert,
            fpdf._sign_extra_certs,
            fpdf._sign_hashalgo,
            fpdf._sign_time,
        )
    return self.buffer</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fpdf" href="index.html">fpdf</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="fpdf.output.serialize_annot" href="#fpdf.output.serialize_annot">serialize_annot</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fpdf.output.OutputProducer" href="#fpdf.output.OutputProducer">OutputProducer</a></code></h4>
<ul class="">
<li><code><a title="fpdf.output.OutputProducer.bufferize" href="#fpdf.output.OutputProducer.bufferize">bufferize</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>